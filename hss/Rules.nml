/*
 *  Hss Format
 *  Copyright (c)2008 Nicolas Cannasse
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License or the LICENSE file for more details.
 */
open Lexer;
open Hss.Ast;
open Hss.Parser;

function unSupported(s, p)
	error Message("UnSupported " + "'" + s + "'") p

function semicolon_opt(s) {
	match s {
	| [< (Semicolon,_) >] -> 1
	| [< >] ->
		var tk, p = stream_token s 0;
		match tk {
		| Keyword Var | BraceClose -> 1
		| _ -> error (Expected_semicolon tk) p
		}
	}
}

function rec begin(s) {
	match s {
	| [< (Eof,_) >] -> []
	| [< r = statement s; p = begin s >] -> r :: p
	}
}

function rec statement(s) {
	match s {
	| [< (Keyword Var,p1); (Const (Ident i),_); (Eq,_); r = rule s; _ = semicolon_opt s >] ->
		(REVar(i, r), punion p1 (pos r))
	| [< (Const (Ident att),p1); (DoubleDot,_); r = rule s; _ = semicolon_opt s >] ->
		(REAttribute(att, r), punion p1 (pos r))
	| [< (Const (Ident namespace),p); (BraceOpen,_); l = statement_list s  >] ->
		(REBlock(namespace, l), p)
	}
}

function rec statement_list(s) {
	match s {
	| [< (BraceClose,_) >] ->
		[]
	| [< re = statement s >] ->
		match fst re {
		| REBlock(name, _)-> error(Unexpected Const(Ident name), pos re)
		| _ ->
		}
		re :: (statement_list s)
	}
}

function rec rule(s) {
	var r = match s {
	| [< (BracketOpen, p1); r = rule s; (BracketClose, p2) >] ->
		(ROr [r], punion p1 p2)
	| [< (ParentOpen, p1); r = rule s; (ParentClose, p2) >] ->
		(match fst r {
		| ROr l -> RGroup l
		| RList l -> RList l
		| _ -> RGroup [r]
		}, punion p1 p2)
	| [< (Const (Int i), p) >] ->
		(RIntRange(i, i), p)
	| [< (Const (Float f), p) >] ->
		(RFloatRange(f, f), p)
	| [< (Const (Ident i), p) >] ->
		(match i {
		| "id" -> RIdent
		| "int" -> RInt
		| "float" -> RFloat
		| "string" -> RString
		| _ -> RId i
		}, p)
	| [< (Op Mul, p) >] -> (RAny , p)
	| [< (Const (String s), p) >] ->
		(RId s, p)
	| [< (Sharp, p1); (Const (Ident i), p2) >] ->
		if (!contiguous(p1, p2)) then
			error(Unexpected (Const (Ident i)), p2);
		(RHex(String.length i), punion p1 p2)
	| [< (Const (Val s), p) >] ->
		(RVal s, p)
	};
	rule_next r s
}

function rec rule_next(r1, s) {
	match s {
	| [< (Comma, _); r2 = rule s >] ->
		(match fst r2 {
		| RList l -> RList (r1 :: l)
		| _ -> RList [r1; r2]
		}, punion(pos r1, pos r2))
	| [< (Eq, p); r2 = rule s >] ->
		var v1, p1 = r1
		var v2, p2 = r2
		var def = match v1 {
		| RId name ->
			match fst r2 {
			| ROr (r2 :: l) -> ROr((RBind(name, r2), punion p1 (pos r2)) :: l)
			| RList (r2 :: l) -> RList((RBind(name, r2), punion p1 (pos r2)) :: l)
			| _ -> RBind(name, r2)
			}
		| _ -> error (Unexpected Eq) p
		}
		(def, punion p1 p2)
	| [< (Op o, po) >] ->
		var p1 = pos r1;
		match (contiguous p1 po, o) {
		| (true, Add) | (true, Mul) ->
			var name = match o {
			| Add -> "Plus"
			| _ -> "Star"
			}
			rule_next (RCall(name, r1), punion p1 po) s
		| _ ->
			rule_binop o r1 (rule s)
		}
	| [< (BraceOpen, p2); r2 = rule s; (BraceClose, p3) >] ->
		var rv = (RList [r1; r2], punion p2 p3);
		rule_next (RCall("Rep", rv), punion (pos r1) p3) s
	| [< r2 = rule s >] ->
		rule_join r1 r2
	| [<  >] ->
		var tk, p = stream_token s 0
		var name = match tk {
		| Sharp -> "Many"      // #
		| Question -> "Opt"    // ?
		| Tild -> "UnOrdered"  // ~
		| _ -> ""
		}
		match (name, fst r1) {
		| ("", _) -> r1
		| _ ->
			stream_junk s 1;
			rule_next (RCall(name, r1), punion(pos r1, p)) s
		}
	}
}

function rec rule_join(r1, r2) {
	var v1, p1 = r1;
	var v2, p2 = r2;
	var p = punion p1 p2;
	match (contiguous p1 p2, v1) {
	| (true, RId name) ->
		function calls_merge(name, p1, r2) {
			match r2 {
			| (RCall(ctl, e), p2) ->
				var c = (RCall(name, e), p2);
				Some (RCall(ctl, c), punion p1 p2)
			| _ ->
				None
			}
		}
		function has_brackets(v) match v {
		| ROr _ | RList _ | RGroup _ | RCall _ -> true
		| _ -> false
		}
		// name(any)? b c; ==> name..[Opt(any); b; c] --> [Opt(name(any)); b; c]
		// name(any)  b c; ==> name..[(any)   ; b; c] --> [name(any); b; c]
		match v2 {
		| ROr (((v21, p21) as r21) :: l)
		| RList (((v21, p21) as r21) :: l) when (contiguous p1 p21) && (has_brackets v21) ->
			var r = match calls_merge name p1 r21 {
			| Some r -> r
			| _ -> (RCall(name, r21), punion p1 p21)
			}
			match v2 {
			| ROr _ -> (ROr (r :: l), p)
			| RList _ -> (RList (r :: l), p)
			| _ -> r2 // dummy
			}
		| ROr _
		| RList _
		| RGroup _ ->
			(RCall(name, r2), p)
		| _ ->
			match calls_merge name p1 r2 {
			| Some r -> r
			| _ -> rule_join_simple r1 r2
			}
		}
	| _ ->
		rule_join_simple r1 r2
	}
}

function rec rule_join_simple(r1, r2) (
	match fst r2 {
	| ROr l -> ROr (r1 :: l)
	| RList (r2::l) -> RList ((rule_join_simple r1 r2) :: l)
	| _  -> ROr [r1; r2]
	}, punion(pos r1, pos r2)
)

// '-' > '/'
function rec rule_binop(o1, r1, r2) (
	match fst r2 {
	| ROr(r2 :: l) -> ROr(rule_binop o1 r1 r2 :: l)
	| RList(r2 :: l) -> RList(rule_binop o1 r1 r2 :: l)
	| ROp(o2, r2, r3) when o1 == Sub -> ROp o2 (rule_binop o1 r1 r2) r3
	| _ -> ROp(o1, r1, r2)
	}, punion(pos r1, pos r2)
)

function rec s_rule_expr(re) {
	match fst re {
	//| REVar(name, r) -> "var " + name + " = " + (s_rule r) + ";\n"
	| REVar(name, r) -> ""
	| REAttribute(name, r) -> name + " : " + (s_rule r) + ";\n"
	| REBlock(name, l) -> name + (if l == [] then "{" else " {\n\t") + String.concat("\t", List.map s_rule_expr l) + "}"
	}
}

type context {
	mutable vars : (string, rule) Map.t;
	mutable eval_rec : int;
	mutable rules : (string, (string, rule) Hashtbl.t) list;
	mutable current : (string, rule) Hashtbl.t;
}

function namespace(ctx, name) {
	function rec loop (name, l) match l {
	| [] -> None
	| (n, r) :: l -> if n == name then Some r else loop name l
	}
	loop name ctx.rules
}

function flatten_units(r) {
	function rec loop(acc, x) {
		match fst x {
		| RId s ->
			s :: acc
		| RGroup l | ROr l | RList l ->
			List.fold loop acc l
		| _ ->
			unSupported (s_rule x) (pos x)
		}
	}
	var v, p = r
	match v {
	| RGroup l | ROr l | RList l ->
		(RUnit(List.fold loop [] l), p)
	| _ ->
		unSupported (s_rule r) p
	}
}

function rec eval(ctx, r) {
	var d, p = r
	match d {
	| RInt
	| RAny
	| RFloat
	| RIdent
	| RString
	| RId _
	| RHex _
	| RUnit _
	| RIntRange _
	| RFloatRange _ ->
		r
	| RVal name ->
		if ctx.eval_rec > 100 then error (Message "Invalid loop in variable expension") p;
		var val = (try Map.find ctx.vars name catch { Not_found -> error Message("Variable not declared '" + name + "'") p });
		ctx.eval_rec := ctx.eval_rec + 1;
		var r = eval ctx val;
		ctx.eval_rec := ctx.eval_rec - 1;
		r
	| RGroup [r] | ROr [r] | RList [r] -> // if single
		eval ctx r
	| RGroup rl ->
		(RGroup(List.map (eval ctx) rl), p)
	| ROr rl ->
		(ROr(List.map (eval ctx) rl), p)
	| RList rl ->
		(RList(List.map (eval ctx) rl), p)
	| RBind (name, r2) ->
		(RBind(name, eval ctx r2), p)
	| ROp(o, r1, r2) ->
		var r1 = eval ctx r1;
		var r2 = eval ctx r2;
		function rangecheck(r) {
			var v, p = r;
			match v {
			| RIntRange(i, j) when i == j -> true
			| RFloatRange(f, g) when f == g -> true
			| _ -> false
			}
		}
		match o {
		| Sub when rangecheck(r1) && rangecheck(r2) -> // convert (e - e) to range
			var pos = punion (pos r1) (pos r2);
			match (fst r1, fst r2) {
			| (RIntRange(i, _), RIntRange(j, _)) ->
				(RIntRange(i, j), pos)
			| (RIntRange(i, _), RFloatRange(f, _)) ->
				(RFloatRange(i * 1.0, f), pos)
			| (RFloatRange(f, _), RFloatRange(g, _)) ->
				(RFloatRange(f, g), pos)
			| (RFloatRange(f, _), RIntRange(i, _)) ->
				(RFloatRange(f, i * 1.0), pos)
			| _ ->
				r // dummy
			}
		| _ ->
			(ROp(o, r1, r2), p)
		}
	| RCall(name, r) ->
		var r = eval ctx r;
		match name {
		| "Unit" -> flatten_units r
		| "LOG" -> printf "LOG : %s\n" (s_rule r); r;
		| _ -> (RCall(name, r), p)
		}
	}
}

function rec recording(ctx, e) {
	var v, p = e;
	match v {
	| REVar(name, rule) ->
		ctx.vars := Map.add ctx.vars name rule;
	//	e
	| REAttribute(attr, rule) ->
		var rule = eval ctx rule;
		Hashtbl.add ctx.current attr rule;
	//	(REAttribute(attr, rule), p)
	| REBlock (name, el) ->
		var old = (ctx.vars, ctx.current);
		ctx.current := match namespace ctx name {
		| Some r -> r
		| _ ->
			var tbl = Hashtbl.create();
			ctx.rules := (name, tbl) :: ctx.rules;
			tbl
		}
		var el = List.map (recording ctx) el;
		ctx.vars := fst old;
		ctx.current := snd old;
	//	(REBlock(name, el), p)
	}
}

function fractional_part(f) {
	var f = if f >= 0. then (f + 0.0000001) else -(f - 0.0000001); // Math.abs
	f - (Math.ffloor f) > 0.0000019
}

function unordered_keep(r) match fst r {
| RCall(n,x) -> match n {
	| "Plus" -> Some (RCall("Star", x), pos r)
	| "Star" -> Some r
	| "Rep" -> match x {
		| (RList [x; (RIntRange(m, n), p)], px) when n > 0 ->
			var vl = (RList [x; (RIntRange(m - 1, n - 1), p)] , px);
			Some (RCall("Rep", vl),pos r)
		| _ -> None
		}
	| _ -> None
	}
| _ -> None
}

function is_optinal(r) match fst r {
| RCall(n,_) when n == "Opt" || n == "Star" -> true
| RCall("Rep", (RList [_; (RIntRange(m, _),_)],_)) -> m <= 0
| _ -> false
}

function all_is_optinal (rl) match rl {
| [] -> true
| _ -> List.all is_optinal rl
}

function vtl_next(vtl) {
	match *vtl {
	| _ :: vl -> vtl := vl
	| _ ->
	}
}

function separator(v) (VParentheses v, pos v)

/*
 * @param vtl : The stack of values
 */
function rec check( vtl : value list ref, v : value, r ) : bool {
	match (fst r, fst v) {
	| (RAny, _)
	| (RFloat, VInt _)
	| (RFloat, VFloat _)
	| (RInt, VInt _)
	| (RIdent, VIdent _)
	| (RString, VString _) ->
		 true
	| (RId s, VIdent n) ->
		s == n
	| (RCall(name, r), _) ->
		check_calls vtl v r name
	| (ROr rl, _) ->
		List.exists (check vtl v) rl;
	| (RHex n, VHex s) ->
		String.length s == n
	| (RUnit l, VUnit(_,s))->
		List.mem s l
	| (RInt, VFloat f) ->
		!(fractional_part f)
	| (RIntRange(min, max), VInt n) ->
		n >= min && n <= max
	| (RIntRange(min, max), VFloat f) ->
		!(fractional_part f) && f >= min * 1.0 && f <= max * 1.0
	| (RFloatRange(min, max), VInt n) ->
		n * 1.0 >= min && n * 1.0 <= max
	| (RFloatRange(min, max), VFloat n) ->
		n >= min && n <= max
	| (_, VLabel (_, v)) ->
		check vtl v r
	| (RBind(s, r), VBind(n, v)) when s == n ->
		check vtl v r
	| (ROp (s, r1, r2), VOp(o, v1, v2)) ->
		(s == Xor || s == o) && check vtl v1 r1 && check vtl v2 r2 // "^" matches arbitrary ops
	| _ ->
		check_complex vtl v r check_normal_groups
	}
}

function rec check_complex(vtl, v, r, mainloop_check) {
	var restore = *vtl;
	var succ = match (fst r, fst v) {
	| (x, VGroup vl) ->
		vtl := List.append vl ((separator v) :: *vtl); // uses VParentheses as Separator
		match x {
		| RGroup rl -> mainloop_check vtl rl
		| RList _ -> false
		| _ -> mainloop_check vtl [r]
		}
	| (x, VList vl) ->
		vtl := List.append vl ((separator v) :: *vtl);
		var rl = match x {
		| RList rl -> rl
		| _ -> [r]
		}
		mainloop_check vtl rl;
	| (RGroup rl, x) ->
		match x {
		//| VGroup vl ->   // already matched
		| VList _ -> false // fails
		| _ ->
			vtl := v :: *vtl; // no separator. think: r(A (B C) D) v(A B C D)
			mainloop_check vtl rl;
		}
	| _ ->
		false
		// printf "UnMatched rule : %s, value : %s\n" (s_rule r, s_value v);
	}
	if (!succ) then
		vtl := restore;
	succ
}
function rec check_normal_groups(vtl, rl) {
	match (rl, *vtl) {
	| (_, (VParentheses _,_) :: vl) -> // separator to prevents "check_repeat" from out-of-bounds
		vtl := vl;
		all_is_optinal rl
	| (r :: rl, v :: vl) ->
		vtl := vl;
		// printf "group-loop stack : %d, value : '%s', rule : '%s'\n" (List.length (*vtl), s_value v, s_rule r);
		(check vtl v r) && (check_normal_groups vtl rl)
	| _ ->
		all_is_optinal rl
	}
}

function rec check_repeat_inner(acc, vtl, r, min, max) {
	var succ = acc >= min;
	match *vtl {
	| (VParentheses _,_) :: vl ->
		if succ then vtl := vl;
		succ
	| v :: vl when max == 0 || acc < max ->
		vtl := vl;
		if check vtl v r then {
			check_repeat_inner (acc + 1) vtl r min max
		} else {
			vtl := v :: *vtl;
			succ
		}
	| _ -> // means (acc != 0 && acc == max) or (vtl == []) then do nothing
		succ
	}
}
function rec check_repeat(vtl, v, r, min, max) {
	vtl := v :: *vtl;
	check_repeat_inner 0 vtl r min max;
}

// ensure that at least one match is made
function rec check_unordered(ensure, vtl, rl) {
	var succ = ensure && all_is_optinal rl;
	match *vtl {
	| [] -> succ
	| v :: vl ->
		vtl := vl;
		match (fst v) {
		| VParentheses _ -> succ
		| _ ->
			var rl, succ = check_unordered_inner vtl [] v rl;
			if succ then check_unordered true vtl rl else ensure && all_is_optinal rl
		}
	}
}
function rec check_unordered_inner(vtl, acc, v, rl) {
	match rl {
	| [] ->
		vtl := v :: *vtl; // if 'v' is not matched then put it back.
		(acc, false)
	| r :: rl ->
		var succ = check vtl v r;
		// Opt(), Star() will put v back to *vtl if matches empty.
		var empty = match *vtl {| [] -> false | (x :: _) -> x === v};
		if succ && !empty then {
			var rl = match unordered_keep r {
			| Some r -> r :: rl
			| None -> rl
			}
			(List.append acc rl, true)
		} else {
			if empty then
				vtl := List.tl(*vtl);
			check_unordered_inner vtl (r :: acc) v rl
		}
	}
}

function rec check_calls(vtl, v, r, name) {
	match (name, fst r) {
	| ("Opt", _) ->
		check_repeat vtl v r 0 1
	| ("Star", _) ->
		check_repeat vtl v r 0 0
	| ("Plus", _) ->
		check_repeat vtl v r 1 0
	| ("Rep", RList [r; (RIntRange(i, j), _)]) ->
		check_repeat vtl v r i j
	| ("Many", _) ->      // Similar to Plus, But for VList(,)
		match fst v {
		| VList vl -> List.all (function (v) check vtl v r) vl
		| _ -> check vtl v r
		}
	| ("UnOrdered", _) ->
		check_complex vtl v r (check_unordered false)
	| _ ->
		match (fst v) {
		| VCall(c, l) ->
			check vtl c (RId name, pos r) && check vtl (VList l, pos v) r
		| _ ->
			false
		}
	}
}

var globals = Hashtbl.create()
var special = Hashtbl.create()
var context = { vars = Map.empty(); eval_rec = 0; rules = [("globals", globals); ("special", special)]; current = globals }

function pathdir(s) {
	function rec loop(acc, l) match l {
	| [] -> assert()
	| x :: (_ :: _) as l -> loop (acc + "/" + x) l
	| [_] -> acc
	}
	var s = String.concat "/" (String.split s "\\");
	match String.split s "/" {
	| h :: tl -> loop h tl
	| _ -> "."
	}
}

function loadfile(rule, cssdir) {
	var file = if Sys.exists rule then rule else (if cssdir != "" then cssdir + "/" + rule else rule)
	var file = if Sys.exists file then file else (pathdir Sys.executable_path()) + "/" + rule
	var file = if Sys.exists file then file else rule // error f
	var chs = IO.read_file (file) true
	var lex = Lexer.create Buffer.create();
	Lexer.input lex file chs 1 0;
	var el = Hss.Parser.parse(begin, lex);
	List.iter (recording context) el;
}

var mode_append = &false
var file_custom = &""
var loaded = &false
function load(def, cssdir) {
	var input = *file_custom;
	if (input == "" || *mode_append == true) then
		loadfile(def, cssdir);
	if (input != "") then
		loadfile(input, cssdir);
	loaded := true
}

function append() {
	mode_append := true
}

function custom(f) {
	file_custom := f
}
