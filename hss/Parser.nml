/*
 *  Hss Format
 *  Copyright (c)2008 Nicolas Cannasse
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License or the LICENSE file for more details.
 */
open Lexer;
open Hss.Ast;

type error_msg {
	Unexpected : token;
	Message : string;
	Class_expected;
	Expected_semicolon : token;
}

exception Error : (error_msg , pos)

function error_msg(m) {
	match m {
	| Unexpected t -> "Unexpected " + s_token t
	| Class_expected -> "A node class is expected here"
	| Expected_semicolon t -> "Unexpected " + "'" + s_token t + "' maybe missing ;"
	| Message s -> s
	}
}

function error(m,p) {
	throw Error(m,p)
}

function mk(t,p) {
	(t,p)
}

function semicolon(s) {
	match s {
	| [< (Semicolon,p) >] -> p
	| [< (tk,p) >] -> error (Expected_semicolon tk) p
	}
}

function opt_semicolon(s) {
	match s {
	| [< (Semicolon,_) >] -> true
	| [< >] -> false
	}
}

function rec program(s) {
	match s {
	| [< (Eof,_) >] -> []
	| [< e = expr s; p = program s >] -> e :: p
	}
}

function rec expr(s) {
	match s {
	| [< (Keyword Var,p1); (Const (Ident i),_); (Eq,_) >] -> match s {
		| [< (BraceOpen,p2); l = expr_list s >] -> (EVarBlock i l, punion p1 p2)
		| [< v = value s; p2 = semicolon s >] -> (EVar i v, punion p1 p2)
		}
	| [< (Keyword Include,p1); (ParentOpen,_); (Const (String css),_); (ParentClose,p2); _ = opt_semicolon s >] -> (EInclude css, punion p1 p2)
	| [< (Keyword Import,p); (ParentOpen,_); v = value s; (ParentClose,_); _ = opt_semicolon s >] -> (EImport v, p)
	| [< (Keyword Keyframes,p1); (Const (Ident n),p2); (BraceOpen,_); l = keyframes s; >] -> (EKeyframes n l, punion p1 p2)
	| [< (Keyword Media,p); v = media_list s; (BraceOpen,_); l = expr_list s; >] -> (EMedia v l, p)
	| [< (Const (Val v),p) >] -> expr_dollar v p s
	| [< c = class_list s true; (BraceOpen,p); l = expr_list s; >] -> (EBlock c l, p)
	}
}

function rec media_list(s) {
	match s {
	| [< (Comma, p) >] -> (MComma,p)::(media_list s)
	| [< (Const (String str),p) >] -> (MQuotes str, p)::(media_list s)
	| [< (Const (Ident id), p) >] ->
		var id = String.lowercase id;
		(match id {
		| "not" -> (MNot, p)
		| "only" -> (MOnly, p)
		| "and" -> (MAnd, p)
		| "all" | "screen" | "print" | "speech" -> (MType id, p)
		| _ -> error Unexpected(Const (Ident id)) p
		})::(media_list s)
	| [< (ParentOpen,_); (Const (Ident id),p); (ParentClose,_) >] -> (MSigAttr id, p)::(media_list s)
	| [< (ParentOpen,_); (Const (Ident id),p); (DoubleDot,_); v = value s; (ParentClose,_)>] -> (MAttr id v, p)::(media_list s)
	| [< (ParentOpen,p1); l = media_list s; (ParentClose,p2) >] -> (MParent l, punion p1 p2)::(media_list s)
	| [< >] -> []
	}
}

function rec keyframes(s) {
	match s {
	| [< (BraceClose,_) >] -> []
	| [< (Const (Ident i),p1);(BraceOpen,_) >] -> ((VIdent i,p1), expr_list s) :: keyframes s
	| [< (Const (Int i),p1);(Percent,p2);(BraceOpen,_) >] -> ((VUnit(1.0 * i,"%"), punion p1 p2), expr_list s) :: keyframes s
	| [< (v, p) >] -> error(Unexpected v, p)
	}
}

function rec block_params(s) {
	match s {
	| [< (Const (Ident i), p1); (Eq,_); v = value s; >] ->
		var param = (VBind i v, punion p1 (pos v));
		var tk = stream_token s 0;
		match fst tk {
		| Semicolon -> (stream_junk s 1); param :: (block_params s)
		| ParentClose -> [param]
		| t -> error(Unexpected t, snd tk)
		}
	| _ ->
		var tk = stream_token s 0;
		match fst tk {
		| ParentClose -> []
		| t -> error(Unexpected t, snd tk)
		}
	}
}

function rec expr_list(s) {
	match s {
	| [< (BraceClose,_) >] -> []
	| [< >] ->
		(match s {
		| [< (Const (Ident att),p); (DoubleDot,_); v = value s; _ = semicolon s >] -> (EAttribute att v,p)
		| [< (Const (Val v),p) >] -> expr_dollar v p s
		| [< e = expr s >] -> e
		}) :: expr_list s
	}
}

function rec expr_dollar_next(s) {
	match s {
	| [< (Const (Val v),p) >] ->
		match s {
		| [< (ParentOpen,_); l = block_params s; (ParentClose,_); _ = semicolon s >] -> (EUseBlock v l, p)
		| [< (Semicolon, _); >] -> (EUseBlock v [], p)
		| [< (Op BoolAnd,_); b = expr_dollar_next s; >] -> (EIfDefine (v, true) b, p)
		| [< (Op BoolOr ,_); b = expr_dollar_next s; >] -> (EIfDefine (v, false) b, p)
		| [< (tk, p) >] -> error (Expected_semicolon tk) p
		}
	| [< (Const (Ident att),p); (DoubleDot,_); v = value s; _ = semicolon s >] -> (EAttribute att v,p)
	| [< (Keyword Import,p); (ParentOpen,_); v = value s; (ParentClose,_); _ = opt_semicolon s >] -> (EImport v, p)
	| [< (BraceOpen, p); l = expr_list s >] -> (ESub l, p)
	| [< (tk, p) >] -> error(Unexpected tk, p)
	}
}

function rec expr_dollar(v: string, p: pos, s) {
	match s {
	| [< (ParentOpen,_); l = block_params s; (ParentClose,_); _ = semicolon s >] -> (EUseBlock v l, p)
	| [< (Op BoolAnd,_); b = expr_dollar_next s; >] -> (EIfDefine (v, true) b, p)
	| [< (Op BoolOr ,_); b = expr_dollar_next s; >] -> (EIfDefine (v, false) b, p)
	| [< _ = semicolon s >] -> (EUseBlock v [],p)
	}
}

function rec value(s) {
	match s {
	| [< (Sharp,p) >] -> value_next (value_hex p s) s
	| [< (Const (Ident i),p1) >] ->
		match s {
		| [< (Eq,_); v = value s >] ->
			function bind(v) {
				(VBind i v,punion p1 (pos v))
			}
			match v {
			| (VList (v :: l),p2) -> (VList (bind v :: l), punion p1 p2)
			| (VGroup (v :: l),p2) -> (VGroup (bind v :: l), punion p1 p2)
			| _ -> bind v
			}
		| [< >] ->
			value_next (VIdent i,p1) s
		}
	| [< (Const (String str),p) >] -> value_next (VString str,p) s
	| [< (Const (Int i),p) >] -> value_unit (i * 1.0) (VInt i, p) s
	| [< (Const (Float f),p) >] -> value_unit f (VFloat f, p) s
	| [< (Const (Val v),p) >] -> value_next (VVar v,p) s
	| [< (Op Sub, p1); (Const (Val v),p2) >] -> value_next (VOp Sub (VInt 0, p1) (VVar v, p2), punion p1 p2) s
	| [< (ParentOpen,p1); p = value s; (ParentClose,p2) >] -> value_next (VParentheses p,punion p1 p2) s
	}
}

function rec value_unit(f,v,s) {
	var p1 = pos v
	var p2 = pos (stream_token s 0)
	var v = if (p1.pmax == p2.pmin && p1.pline == p2.pline) then
		match s {
		| [< (Const (Ident i),_) >] -> (VUnit f i, punion p1 p2)
		| [< (Percent,_) >] -> (VUnit f "%", punion p1 p2)
		| [< >] -> v
		}
	else
		v;
	value_next v s
}

function rec value_join(v,v2) (
	match fst v2 {
	| VGroup l      -> VGroup (v :: l)
	| VList (v2::l) -> VList ((value_join v v2) :: l)
	| VLabel (l,v2) -> VLabel l (value_join v v2)
	| _  -> VGroup [v;v2]
	},
	punion(pos v, pos v2)
)

function rec value_next(v,s) {
	match s {
	| [< (ParentOpen,p1); p = value s; (ParentClose,p2) >] ->
		match p {
		| (VList l,_) -> value_next (VCall v l, punion (pos v) p2) s
		| _ -> match (fst v, (pos v).pmax == p1.pmin && (pos v).pline == p1.pline) {
			| (_, true) | (VIdent "CSS",_) -> value_next (VCall v [p], punion (pos v) p2) s
			| _ -> value_join v (value_next (VParentheses p,punion p1 p2) s)
			}
		}
	| [< (Exclamation,p1); (Const (Ident i),p2) >] ->
		(VLabel i v,punion p1 p2)
	| [< (Op o,_); v2 = value s >] ->
		function rec loop(o, v, v2) {
			(match (fst v2) {
			| VGroup (v2 :: l) -> VGroup (loop o v v2 :: l)
			| VList  (v2 :: l) -> VList  (loop o v v2 :: l)
			| VLabel (l,v2)    -> VLabel l (loop o v v2)
			| VOp(o2, v1, v2) when (o2 == Add || o2 == Sub || o == Mul || o == Div) -> VOp o2 (loop o v v1) v2
			| _ -> VOp o v v2
			}, punion (pos v) (pos v2))
		}
		loop o v v2
	| [< (Comma,_); v2 = value s >] ->
		function rec loop(v2) {
			var p = punion (pos v) (pos v2);
			match fst v2 {
			| VList l -> (VList (v :: l), p)
			| VLabel (l,v2) -> (VLabel l (loop v2), p)
			| _ -> (VList [v;v2], p)
			}
		}
		loop v2
	| [< v2 = value s >] ->
		value_join v v2
	| [< >] ->
		v
	}
}

function rec class_list(s,first) {
	match s {
	| [< c = class s first >] ->
		match s {
		| [< (Comma,_) >] -> c :: class_list s false
		| [< >] -> [c]
		}
	}
}

function rec parse_attr_value(s) {
	match s {
	| [< (Const (Ident v),_) >] -> v
	| [< (Const (String s),_) >] -> s
	}
}

function rec parse_attribute(s) {
	match s {
	| [< (BracketClose,p) >] -> (p, AExists)
	| [< (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, AEqual v)
	| [< (Tild,_); (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, AContain v)
	| [< (Op Or,_); (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, ADash v)
	| [< (Op Xor,_); (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, ABegin v)
	| [< (Dollar,_); (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, AEnd v)
	| [< (Op Mul,_); (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, ASubstr v)
	}
}

function rec value_hex(p,s) {
	var str = &"";
	var pos = &p;
	var hex = Regexp.build "^[A-Za-z0-9]+$";
	function rec loop(i) {
		var t = stream_token s i;
		var p = *pos;
		var p2 = snd t;
		pos := p2;
		// contiguous
		if p.pline != p2.pline || p.pmax != p2.pmin then
			i
		else match fst t {
		| Const (Ident id) when Regexp.find hex id 0 String.length(id) ->
			str := *str + id;
			loop (i+1)
		| Const (Int k) when k >= 0 ->
			str := *str + string k;
			loop (i+1)
		| _ ->
			i
		}
	}
	var n = loop 0;
	if n == 0 then error (Message "Expected hexadecimal value here") p;
	stream_junk s n;
	(VHex (*str), punion p (*pos))
}

function rec parse_cond_macro(s) {
	match s {
	| [< (Exclamation,p1); v = parse_cond_macro s; >] -> (VLabel "!" v, punion p1 (pos v))
	| [< (ParentOpen,p1); v = cond_macro_next (parse_cond_macro s) s; (ParentClose,p2) >] -> (VParentheses v, punion p1 p2)
	| [< (Const (Ident i),p)>] -> (VIdent i,p)
	| [< (t,p)>] -> error(Unexpected t, p)
	}
}

function rec cond_macro_next(v, s) {
	match s {
	| [< (Op o,_); v2 = parse_cond_macro s >] ->
		function rec loop(o, v, v2) {
			(match (fst v2) {
			| VOp(o2, v1, v2) when (o2 == BoolOr || o == BoolAnd) -> VOp o2 (loop o v v1) v2
			| _ -> VOp o v v2
			}, punion (pos v) (pos v2))
		}
		(loop o v v2)
	| [< >] ->
		v
	}
}

function rec class(s,first) {
	var c = { node = None; id = None; classes = []; sub = None; selector = []; attributes = []; operator = OpDefault; };
	var pos = &null_pos;
	var last = &None;
	function rec loop(i) {
		var t = stream_token s i;
		var p = *pos;
		var p2 = snd t;
		pos := p2;
		// contiguous
		if (i > 0 || c.attributes != []) && (p.pline != p2.pline || p.pmax != p2.pmin) then
			i
		else match *last {
		| None -> // STATE 1
			match fst t {
			| Dot ->
				last := Some Dot;
				loop (i+1)
			| Const (Ident id) ->
				c.node := Some id;
				loop (i+1)
			| Sharp when c.id == None ->
				last := Some Sharp;
				loop (i+1)
			| DoubleDotx2 ->
				last := Some DoubleDotx2;
				loop (i+1)
			| Op Mul when i == 0 ->
				c.node := Some "*";
				loop 1
			| BracketOpen ->
				match fst (stream_token s (i+1)) {
				| Const (Ident att) ->
					stream_junk s (i + 2);
					var p, op = parse_attribute s;
					c.attributes := (att, op) :: c.attributes;
					pos := p;
					loop 0
				| _ ->
					i+1
				}
			| Selector s ->
				c.selector := (PSelector s)::c.selector;
				loop (i+1)
			| SelectorCall (s,e) ->
				c.selector := PSelectorCall(s, e)::c.selector;
				pos := {psource = p2.psource; pline = p2.pline; pmin = p2.pmin; pmax = p2.pmax + 1};
				loop (i+2)
			| ParentOpen when i == 1 && c.node == Some "CSS" ->
				match (stream_token s (i + 1), stream_token s (i + 2)) {
				| ((Const (String s),_), (ParentClose,p)) ->
					c.node := Some s;
					pos := p;
					loop (i+3)
				| _ -> i
				}
			| _ ->
				i
			}
		| Some v -> // STATE 2
			last := None;
			match fst t {
			| Const (Ident id) ->
				match v {
				| Dot -> c.classes := List.append c.classes [id];
				| Sharp -> c.id := Some id;
				| DoubleDotx2 -> c.selector:= (PSelector2 id)::c.selector;
				| _ -> error (Unexpected v) p // never run to this line
				}
			| t -> error (Unexpected t) p2
			}
			loop (i+1)
		}
	}
	c.operator := match s {
	| [< (Gt,_) >] -> OpChild
	| [< (Tild,_) >] -> OpPreceding false
	| [< (Op Add,_) >] -> OpPreceding true
	| [< (Op And,p) >] ->
		var nxt = stream_token s 0;
		match (fst nxt) {
		| Gt     -> stream_junk s 1; OpChild
		| Tild   -> stream_junk s 1; OpPreceding false
		| Op Add -> stream_junk s 1; OpPreceding true
		| _ ->
			var p2 = snd nxt;
			if (p.pline == p2.pline && p.pmax == p2.pmin) then OpJoint else OpDefault
		}
	| [< >] -> OpDefault
	}
	var n = loop 0;
	if n == 0 && c.attributes == [] then {
		error (if first then Unexpected fst(stream_token s 0) else Class_expected) (*pos)
	}
	c.attributes := List.rev c.attributes;
	stream_junk s n;
	match fst(stream_token s 0) {
	| BraceOpen | Comma -> ()
	| _ -> try c.sub := Some (class s false) catch { Error (Class_expected,_) -> () }
	}
	c
}

var defines = &Set.empty();

function add_defines(s) defines := Set.add(*defines, s)

function rec eval(v) {
	match fst v {
	| VIdent i -> Set.exists (*defines) i
	| VLabel(_, v) -> !(eval v)
	| VParentheses v -> eval v
	| VOp(BoolAnd, v1, v2) -> (eval v1) && eval(v2)
	| VOp(BoolOr, v1, v2) -> (eval v1) || eval(v2)
	| _ -> error Message("Invalid condition expression " + (s_value v)) (pos v)
	}
}

function parse(lexer) {
	var mstack = &[]
	var s = &neko("null")
	function rec next_token() {
		process_token(Lexer.token lexer (*Hss.Lexer.expr))
	}
	function rec skip_tokens() {
		var h = List.hd(*mstack);
		var t = &next_token();
		while (*mstack) != [] && h === List.hd(*mstack) {
			if fst(*t) == Eof then error Message("UnClosed @if/@else") pos(*t);
			t := next_token();
		}
		*t
	}
	function rec cond_macro(k, t) {
		match k {
		| PrIf ->
			var stub = &false;
			mstack := stub :: (*mstack);
			match eval parse_cond_macro(*s) {
			| true -> stub := true; next_token()
			| _ -> skip_tokens()
			}
		| PrEnd when (*mstack != []) ->
			mstack := List.tl(*mstack);
			match (*mstack) {
			| x::_ when !(*x) -> skip_tokens()
			| _ -> next_token()
			}
		| PrElse | PrElseIf when (*mstack != []) ->
			if (*List.hd(*mstack)) then {
				skip_tokens()
			} else if k == PrElse then {
				mstack := (&true) :: List.tl(*mstack);
				next_token()
			} else {
				mstack := List.tl(*mstack);
				cond_macro PrIf t
			}
		| _ ->
			t
		}
	}
	function rec process_token(t) {
		match fst t {
		| Comment s | CommentLine s -> next_token()
		| Keyword k -> match *mstack {
			| _::x::_ when !(*x) && k != PrEnd -> skip_tokens() // when parent condition is false
			| _ -> cond_macro k t
			}
		| _ -> t
		}
	}
	s := stream next_token;
	try {
		program (*s)
	} catch {
	| Stream_error ->
		var tk,p = neko("s[0].cache[$asize(s[0].cache)-1]"); // get last from stream
		error Unexpected(tk) p
	}
}
