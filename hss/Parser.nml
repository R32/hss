/*
 *  Hss Format
 *  Copyright (c)2008 Nicolas Cannasse
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License or the LICENSE file for more details.
 */
open Lexer;
open Hss.Ast;

type error_msg {
	Unexpected : token;
	Message : string;
	Class_expected;
	Expected_semicolon : token;
}

exception Error : (error_msg , pos)

function error_msg(m) {
	match m {
	| Unexpected t -> "Unexpected " + s_token t
	| Class_expected -> "A node class is expected here"
	| Expected_semicolon t -> "Unexpected " + "'" + s_token t + "' maybe missing ;"
	| Message s -> s
	}
}

function error(m,p) {
	throw Error(m,p)
}

function mk(t,p) {
	(t,p)
}

function semicolon(s) {
	match s {
	| [< (Semicolon,p) >] -> p
	| [< (tk,p) >] -> error (Expected_semicolon tk) p
	}
}

function opt_semicolon(s) {
	match s {
	| [< (Semicolon,_) >] -> true
	| [< >] -> false
	}
}

function rec program(s) {
	match s {
	| [< (Eof,_) >] -> []
	| [< e = expr s; p = program s >] -> e :: p
	}
}

function rec expr(s) {
	match s {
	| [< (Keyword Var,p1); (Const (Ident i),_); (Eq,_) >] ->
		match s {
		| [< (BraceOpen,p2); l = expr_list s >] -> (EVarBlock i l, punion p1 p2)
		| [< v = value s; p2 = semicolon s >] -> (EVar i v, punion p1 p2)
		}
	| [< (Include,p1); (ParentOpen,_); (Const (String css),_); (ParentClose,p2); _ = opt_semicolon s >] -> (EInclude css, punion p1 p2)
	| [< (Import,p); (ParentOpen,_); v = value s; (ParentClose,_); _ = opt_semicolon s >] -> (EImport v, p)
	| [< (Keyframes,p1); (Const (Ident n),p2); (BraceOpen,_); l = keyframes s; >] -> (EKeyframes n l, punion p1 p2)
	| [< (Media,p); v = media_list s; (BraceOpen,_); l = expr_list s; >] -> (EMedia v l, p)
	| [< (Const (Val v),p) >] -> expr_dollar v p s
	| [< c = class_list s true; (BraceOpen,p); l = expr_list s; >] -> (EBlock c l, p)
	}
}

function rec media_list(s) {
	match s {
	| [< (Comma, p) >] -> (MComma,p)::(media_list s)
	| [< (Const (String str),p) >] -> (MCSS str, p)::(media_list s)
	| [< (Const (Ident id), p) >] ->
		var id = String.lowercase id;
		(match id {
		| "not" -> (MNot, p)
		| "only" -> (MOnly, p)
		| "and" -> (MAnd, p)
		| "all" | "screen" | "print" | "speech" -> (MType id, p)
		| _ -> error Unexpected(Const (Ident id)) p
		})::(media_list s)
	| [< (ParentOpen,_); (Const (Ident id),p); (ParentClose,_) >] -> (MSigAttr id, p)::(media_list s)
	| [< (ParentOpen,_); (Const (Ident id),p); (DoubleDot,_); v = value s; (ParentClose,_)>] -> (MAttr id v, p)::(media_list s)
	| [< (ParentOpen,p1); l = media_list s; (ParentClose,p2) >] -> (MParent l, punion p1 p2)::(media_list s)
	| [< >] -> []
	}
}

function rec keyframes(s) {
	match s {
	| [< (BraceClose,_) >] -> []
	| [< (Const (Ident str), p1); (BraceOpen,_); >] ->
		((VString str, p1), expr_list s) :: keyframes s
	| [< (Const (Int i), p1); (Percent, p2); (BraceOpen,_); >] ->
		((VUnit(1.0 * i, "%"), punion p1 p2), expr_list s) :: keyframes s
	| [< (Keyword Var,p); >] -> error Message("'" + (s_keyword Var) + "' are not allowed")  p
	| [< (v, p) >] -> error(Unexpected v, p)
	}
}

function rec block_params(s) {
	match s {
	| [< (Const (Ident i), p1); (Eq,_); v = value s; >] ->
		var param = (VBind i v, punion p1 (pos v));
		var tk = stream_token s 0;
		match fst tk {
		| Semicolon -> (stream_junk s 1); param :: (block_params s)
		| ParentClose -> [param]
		| t -> error(Unexpected t, snd tk)
		}
	| _ ->
		var tk = stream_token s 0;
		match fst tk {
		| ParentClose -> []
		| t -> error(Unexpected t, snd tk)
		}
	}
}

function rec expr_list(s) {
	match s {
	| [< (BraceClose,_) >] -> []
	| [< >] ->
		(match s {
		| [< (Const (Ident att),p); (DoubleDot,_); v = value s; _ = semicolon s >] -> (EAttribute att v,p)
		| [< (Const (Val v),p) >] -> expr_dollar v p s
		| [< e = expr s >] -> e
		}) :: expr_list s
	}
}

function rec expr_dollar_next(s) {
	match s {
	| [< (Const (Val v),p) >] ->
		match s {
		| [< (ParentOpen,_); l = block_params s; (ParentClose,_); _ = semicolon s >] -> (EUseBlock v l, p)
		| [< (Semicolon, _); >] -> (EUseBlock v [], p)
		| [< (Op BoolAnd,_); b = expr_dollar_next s; >] -> (EIfDefine (v, true) b, p)
		| [< (Op BoolOr ,_); b = expr_dollar_next s; >] -> (EIfDefine (v, false) b, p)
		| [< (tk, p) >] -> error (Expected_semicolon tk) p
		}
	| [< (Const (Ident att),p); (DoubleDot,_); v = value s; _ = semicolon s >] -> (EAttribute att v,p)
	| [< (Import,p); (ParentOpen,_); v = value s; (ParentClose,_); _ = opt_semicolon s >] -> (EImport v, p)
	| [< (BraceOpen, p); l = expr_list s >] -> (ESub l, p)
	| [< (tk, p) >] -> error(Unexpected tk, p)
	}
}

function rec expr_dollar(v: string, p: pos, s) {
	match s {
	| [< (ParentOpen,_); l = block_params s; (ParentClose,_); _ = semicolon s >] -> (EUseBlock v l, p)
	| [< (Op BoolAnd,_); b = expr_dollar_next s; >] -> (EIfDefine (v, true) b, p)
	| [< (Op BoolOr ,_); b = expr_dollar_next s; >] -> (EIfDefine (v, false) b, p)
	| [< _ = semicolon s >] -> (EUseBlock v [],p)
	}
}

function rec value(s) {
	match s {
	| [< (Sharp,p) >] -> value_next (value_hex p s) s
	| [< (Const (Ident i),p1) >] ->
		match s {
		| [< (Eq,_); v = value s >] ->
			function bind(v) {
				(VBind i v,punion p1 (pos v))
			}
			match v {
			| (VList (v :: l),p2) -> (VList (bind v :: l), punion p1 p2)
			| (VGroup (v :: l),p2) -> (VGroup (bind v :: l), punion p1 p2)
			| _ -> bind v
			}
		| [< >] ->
			value_next (VIdent i,p1) s
		}
	| [< (Const (String str),p) >] -> value_next (VString str,p) s
	| [< (Const (Int i),p) >] -> value_unit (i * 1.0) (VInt i, p) s
	| [< (Const (Float f),p) >] -> value_unit f (VFloat f, p) s
	| [< (Const (Val v),p) >] -> value_next (VVar v,p) s
	| [< (Op Sub, p1); (Const (Val v),p2) >] -> value_next (VOp Sub (VInt 0, p1) (VVar v, p2), punion p1 p2) s
	| [< (ParentOpen,p1); p = value s; (ParentClose,p2) >] -> value_next (VParentheses p,punion p1 p2) s
	}
}

function rec value_unit(f,v,s) {
	var p1 = pos v
	var p2 = pos (stream_token s 0)
	var v = if (p1.pmax == p2.pmin && p1.pline == p2.pline) then
		match s {
		| [< (Const (Ident i),_) >] -> (VUnit f i, punion p1 p2)
		| [< (Percent,_) >] -> (VUnit f "%", punion p1 p2)
		| [< >] -> v
		}
	else
		v;
	value_next v s
}

function rec value_next(v,s) {
	match s {
	| [< (ParentOpen,_); p = value s; (ParentClose,p2) >] ->
		var args = match p {
		| (VList l,_) -> l
		| _ -> [p]
		}
		value_next (VCall v args, punion (pos v) p2) s
	| [< (Exclamation,p1); (Const (Ident i),p2) >] ->
		(VLabel i v,punion p1 p2)
	| [< (Op o,_); v2 = value s >] ->
		function rec loop(o, v, v2) {
			var p = punion (pos v) (pos v2);
			match fst v2 {
			| VOp(o2, v1, v2) when (o2 == Add || o2 == Sub || o == Mul || o == Div) ->
				(VOp o2 (loop o v v1) v2, p)
			| _ ->
				(VOp o v v2, p)
			}
		}
		match fst v2 {
		| VList (v2 :: l) -> (VList  ((loop o v v2) :: l), punion (pos v) (pos v2))
		| VGroup(v2 :: l) -> (VGroup ((loop o v v2) :: l), punion (pos v) (pos v2))
		| _-> loop o v v2
		}
	| [< (Comma,_); v2 = value s >] ->
		function rec loop(v2) {
			var p = punion (pos v) (pos v2);
			match fst v2 {
			| VList l -> (VList (v :: l), p)
			| VLabel (l,v2) -> (VLabel l (loop v2), p)
			| _ -> (VList [v;v2], p)
			}
		}
		loop v2
	| [< v2 = value s >] ->
		function rec loop(v2) {
			var p = punion (pos v) (pos v2);
			match fst v2 {
			| VGroup l -> (VGroup (v :: l), p)
			| VList (v2 :: l) -> (VList (loop v2 :: l), p)
			| VLabel (l,v2) -> (VLabel l (loop v2), p)
			| _ -> (VGroup [v;v2], p)
			}
		}
		loop v2
	| [< >] ->
		v
	}
}

function rec class_list(s,first) {
	match s {
	| [< c = class s first >] ->
		match s {
		| [< (Comma,_) >] -> c :: class_list s false
		| [< >] -> [c]
		}
	}
}

function rec parse_attr_value(s) {
	match s {
	| [< (Const (Ident v),_) >] -> v
	| [< (Const (String s),_) >] -> s
	}
}

function rec parse_attribute(s) {
	match s {
	| [< (BracketClose,p) >] -> (p, AExists)
	| [< (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, AEqual v)
	| [< (Tild,_); (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, AContain v)
	| [< (Op Or,_); (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, ADash v)
	| [< (Op Xor,_); (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, ABegin v)
	| [< (Dollar,_); (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, AEnd v)
	| [< (Op Mul,_); (Eq,_); v = parse_attr_value s; (BracketClose,p) >] -> (p, ASubstr v)
	}
}

function rec value_hex(p,s) {
	var str = &"";
	var pos = &p;
	var hex = Regexp.build "^[A-Za-z0-9]+$";
	function rec loop(i) {
		var t = stream_token s i;
		var p = *pos;
		var p2 = snd t;
		pos := p2;
		// contiguous
		if p.pline != p2.pline || p.pmax != p2.pmin then
			i
		else match fst t {
		| Const (Ident id) when Regexp.find hex id 0 String.length(id) ->
			str := *str + id;
			loop (i+1)
		| Const (Int k) when k >= 0 ->
			str := *str + string k;
			loop (i+1)
		| _ ->
			i
		}
	}
	var n = loop 0;
	if n == 0 then error (Message "Expected hexadecimal value here") p;
	stream_junk s n;
	(VHex (*str), punion p (*pos))
}

function rec class(s,first) {
	var c = { node = None; id = None; classes = []; sub = None; selector = []; attributes = []; operator = OpDefault; };
	var pos = &null_pos;
	var last = &None;
	function rec loop(i) {
		var t = stream_token s i;
		var p = *pos;
		var p2 = snd t;
		pos := p2;
		// contiguous
		if (i > 0 || c.attributes != []) && (p.pline != p2.pline || p.pmax != p2.pmin) then
			i
		else match *last {
		| None -> // STATE 1
			match fst t {
			| Dot ->
				last := Some Dot;
				loop (i+1)
			| Const (Ident id) ->
				c.node := Some id;
				loop (i+1)
			| Sharp when c.id == None ->
				last := Some Sharp;
				loop (i+1)
			| DoubleDotx2 ->
				last := Some DoubleDotx2;
				loop (i+1)
			| Op Mul when i == 0 ->
				c.node := Some "*";
				loop 1
			| BracketOpen ->
				match fst (stream_token s (i+1)) {
				| Const (Ident att) ->
					stream_junk s (i + 2);
					var p, op = parse_attribute s;
					c.attributes := (att, op) :: c.attributes;
					pos := p;
					loop 0
				| _ ->
					i+1
				}
			| Selector s ->
				c.selector := (PSelector s)::c.selector;
				loop (i+1)
			| SelectorCall (s,e) ->
				c.selector := PSelectorCall(s, e)::c.selector;
				pos := {psource = p2.psource; pline = p2.pline; pmin = p2.pmin; pmax = p2.pmax + 1};
				loop (i+2)
			| ParentOpen when i == 1 && c.node == Some "CSS" ->
				match (stream_token s (i + 1), stream_token s (i + 2)) {
				| ((Const (String s),_), (ParentClose,p)) ->
					c.node := Some s;
					pos := p;
					loop (i+3)
				| _ -> i
				}
			| _ ->
				i
			}
		| Some v -> // STATE 2
			last := None;
			match fst t {
			| Const (Ident id) ->
				match v {
				| Dot -> c.classes := List.append c.classes [id];
				| Sharp -> c.id := Some id;
				| DoubleDotx2 -> c.selector:= (PSelector2 id)::c.selector;
				| _ -> error (Unexpected v) p // never run to this line
				}
			| t -> error (Unexpected t) p2
			}
			loop (i+1)
		}
	}

	var opt = (stream_token s 0);
	c.operator := match s {
	| [< (Gt,_) >] -> OpChild
	| [< (Tild,_) >] -> OpPreceding false
	| [< (Op Add,_) >] -> OpPreceding true
	| [< (Op And,p) >] ->
		match fst (stream_token s 0) {
		| Dot | Selector _ | DoubleDotx2 | BracketOpen | SelectorCall _ -> OpJoint
		| _ -> error Unexpected(Op And) p
		}
	| [< >] -> OpDefault
	}
	var n = loop 0;
	if n == 0 && c.attributes == [] then {
		if c.operator != OpDefault then error Unexpected(fst opt) (snd opt);
		error (if first then Unexpected fst(stream_token s 0) else Class_expected) (*pos)
	}
	c.attributes := List.rev c.attributes;
	stream_junk s n;
	match fst(stream_token s 0) {
	| BraceOpen | Comma -> ()
	| _ -> try c.sub := Some (class s false) catch { Error (Class_expected,_) -> () }
	}
	c
}

function parse(lexer) {
	var last = &(Eof,null_pos);
	function rec next_token() {
		var t = Lexer.token lexer (*Hss.Lexer.expr);
		match fst t {
		| Comment s | CommentLine s ->
			next_token()
		| _ ->
			last := t;
			t
		}
	}
	try {
		program (stream next_token)
	} catch {
		Stream_error -> error Unexpected(fst(*last)) snd(*last)
	}
}
